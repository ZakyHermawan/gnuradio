/*! \page page_fec Forward Error Correction

\section Introduction

This is the gr-fec package. It contains all of the forward error
correction (FEC) blocks, utilities, and examples. To use the FEC
blocks, the Python namespaces is in gnuradio.fec, which would be
normally imported as:

\code
    from gnuradio import fec
\endcode

See the Doxygen documentation for details about the blocks available
in this package.

A quick listing of the details can be found in Python after importing
by using:

\code
    help(fec)
\endcode


\section fec_using Using the FEC Encoders and Decoders

The FECAPI consists of two layers, the coding blocks themselves and
the coder objects. The coding blocks are the encoders or decoders that
fit into the GNU Radio flowgraph and act as shells to move data to and
from the coder objects. It is in the objects that the actual
coding/decoding gets done. The coding blocks use the API of the coder
objects to interact with the scheduler and set up the input/output
item buffers that move data between blocks.

The gr::fec::encoder block is a relatively simple wrapper for the
encoding objects. It uses the encoding object information about the
input/output sizes and input/output item sizes to set up the
interaction with the scheduler. Typically, a coder will add redundancy
to the stream making the output longer by some amount than the input
stream. This block simply takes in an encoder object, specifically an
object that derives from gr::fec::generic_encoder. It also takes in
the input and output items sizes that the encoder will expect, which
we can just ask the encoder for. Typically, the encodes expect
unpacked bytes in and unpacked bytes out.

The gr::fec::decoder block is similarly simple to wrap the decoding
objects. It uses the decoding object information about the
input/output sizes and input/output item sizes to set up the
interaction with the scheduler. Since a decoder typically uses the
redundancy from the input stream to correct for errors, the input
stream will be longer than the output stream by the rate of the
code. This block simply takes in an decoder object, specifically an
object that derives from gr::fec::generic_decoder. It also takes in
the input and output items sizes that the decoder will expect, which
we can just ask the encoder for. The decoders may take a float input
or a byte. The byte may be a hard decision or a quantized soft
decision, depending on how the decoder object behaves.

Normally, though, we don't work directly with the encoder() or
decoder() blocks but a wrapper around those blocks. GNU Radio's gr-fec
package comes with Python classes, fec.extended_encoder and
fec.extended_decoder, to make things easier. For one thing, these
extended hier_block2 blocks take care of the puncturing and
depuncturing operations often found in FEC codes. The other thing that
these blocks do for us is reads the API of the encoder/decoder objects
to properly convert the data in or out, depending on how the coding
object works.

For instance, a generic_decoder takes in floating point values (which
should be soft decisions). However, a decoder might instead want to
work on 8-bit quantized soft decisions and so expects unsigned
chars. Specifying 'uchar' as the
gr::fec::generic_decoder::get_input_conversion() of the decoder block tells the
fec.extended_decoder to convert the float to a byte.

In GRC, we would add an "FEC Extended Encoder" to our transmitter or
an "FEC Extended Decoder" to the receiver. We would then use one of
the encoder or decoder FEC variable blocks to define the parameters of
the particular code we want to use. We can find these codes under the
[Error Coding] category in GRC. The encoders are found under
[Encoders] and similarly the decoders under the [Decoders]
categories. Putting these onto the canvas creates a variable that we
can then pass to the extended encoder or decoder blocks.

Most of the parameters of the encoder and decoder definitions should
be fairly obvious based on the type of code. See the documentation for
each coding object for more details. In the following section \ref
fec_parallelism, we explain the Parallelism and Dimension properties.


\section fec_coding_vars Encoding/Decoding Variables

GNU Radio currently has a minor subset of coders available:

Coders:

\li gr::fec::code::dummy_encoder
\li gr::fec::code::repetition_encoder
\li gr::fec::code::cc_encoder
\li gr::fec::code::ccsds_encoder

Decoders:
\li gr::fec::code::dummy_decoder
\li gr::fec::code::repetition_decoder
\li gr::fec::code::cc_decoder


When building a new FECAPI encoder or decoder, the dummy
encoder/decoder block would be a good place to start. This coding set
does no processing on the data. For the encoder, each bit is simply
passed through directly. For the dummy decoder, the input data are
floats, so -1's become 0 and 1's stay as 1, but nothing else is done
to the data. Mainly, these blocks are used for references and to make
it easy to compare implementations with and without codes by easily
dropping in these objects instead of restructuring the entire
flowgraph. The ber_curve_gen.grc example file uses the dummy codes to
show the curve to compare against the actual codes.

Although mentioned in the convolutional coder and decoder classes, it
is worth another mention. The cc_encoder is a generic convolutional
encoder that can take any value of K, rate, and polynomials to encode
a data stream. However, the cc_decoder is not as general, even though
it is technically parameterized as such. The cc_decoder block
currently <i>only</i> uses K=7, rate=2, and two polynomials (because
the rate is two). We can, in fact, alter the polynomials, but a
default of [109, 79] is typically. Eventually, we will make this block
more generic for different rates and constraint lengths and take this
particular code implementation as the set CCSDS decoder, much like we
have the ccsds_encoder class.

\subsection fec_parallelism Parallelism

The code variables in GNU Radio Companion have the ability to create
multiple encoder/decoder variables by selecting the level of
parallelism. It is up the encoder to understand how to handle the
parallelism. The following discussion explains the difference between
the two levels and how and when to use. Generally, normal applications
will just use a single level of parallelism.

The GRC variable declarations for the different coders has a setting
for <i>Parallelism</i>, which can be either 1 or 2. If set to 1, then
the resulting variable is a list of coder blocks with the same
settings. If set to 2, then the resulting variable is a list of lists
of coder blocks. The code that accepts these variables must understand
how to handle the parallelism. Most applications would set this to 1.

The standard fec.extended_encoder ("FEC Extended Encoder" in GRC) and
fec.extended_decoder ("FEC Extended Decoder" in GRC) can handle a
Parallelism of 1. They accept a list of coder variables as defined by
Dimension 1 and can multithread the application based on the
"Threading Type" setting:

\li <b>None</b>: does no parallel threading of the coders. Even if
Dimension 1 is > 1, the encoder/decoder will ignore this setting and
only use the first object in the list.

\li <b>Ordinary</b>: all "Dimension 1" number (N) of encoder/decoder
blocks will be used in parallel. The hier_block2 will block
deinterleave the packets into N streams (using
gr::blocks::deinterleave with a value of blocksize as the frame length
and no relative rate changes) and pass these to each of the N coders
to process the frames in parallel. The output of each coder is then
interleaved back together to make a single output stream.

\li <b>Capillary</b>: all "Dimension 1" number (N) of encoder/decoder
blocks will be used in parallel, much like in the <b>Ordinary</b>
mode. In this mode, however, the frames get split up in a tree-like
fashion, where each branch launches 2 more branches. This means that N
must be a factor of 2 for this mode to work. It tends to handle the
load of the encoders/decoders better than the <b>Ordinary</b> mode.

Note that the threading modes only work when using constant-length
frames. If using the coders in tagged stream mode where the frame
lengths may change, the <b>Ordinary</b> and <b>Capillary</b> modes are
not available.

The GRC example "ber_curve_gen.grc" uses a Parallelism of 2. This
creates a list of lists of coders. The first dimension of the list
corresponds to the number of Es/N0 values being used in the BER
simulation. This allows the application to process all values of Es/N0
simultaneously. Dimension 2 in this case allows the same concept of
parallelism discussed above with the <b>None</b>, <b>Ordinary</b>, and
<b>Capillary</b> models of threading.


\section fec_api The API of the FECAPI

The FECAPI defined by the parent generic_encoder and generic_decoder
classes defines a set of virtual functions, some pure virtual, to
allow the encoders/decoders to interact with the GNU Radio blocks. See
the associated documentation of the generic_encoder and
generic_decoder classes to know more about each of the API functions,
some of which a child class is <i>required</i> to implement.

The functions of the encoder and decoder are:

\li double gr::fec::generic_encoder::rate()
\li int gr::fec::generic_encoder::get_input_size()
\li int gr::fec::generic_encoder::get_output_size()
\li int gr::fec::generic_encoder::get_history()
\li float gr::fec::generic_encoder::get_shift()
\li const char* gr::fec::generic_encoder::get_input_conversion()
\li const char* gr::fec::generic_encoder::get_output_conversion()
\li bool gr::fec::generic_encoder::set_frame_size(unsigned int frame_size)

Note: there is no get_input_item_size (or output) as the encoders
always expect to work on bits.

\li double gr::fec::generic_decoder::rate()
\li int gr::fec::generic_decoder::get_input_size()
\li int gr::fec::generic_decoder::get_output_size()
\li int gr::fec::generic_decoder::get_history()
\li float gr::fec::generic_decoder::get_shift()
\li int gr::fec::generic_decoder::get_input_item_size()
\li int gr::fec::generic_decoder::get_output_item_size()
\li const char* gr::fec::generic_decoder::get_input_conversion()
\li const char* gr::fec::generic_decoder::get_output_conversion()
\li bool gr::fec::generic_decoder::set_frame_size(unsigned int frame_size)

Whenever an FECAPI object refers to the frame size, it always means
the number of bits in the uncoded frame. This means the number of bits
going into an encoder and the number of bits coming out of a decoder.

\section fec_examples FEC Examples

\li ber_curve_gen.grc
\li ber_test.grc
\li fecapi_decoders.grc
\li fecapi_encoders.grc
\li fecapi_tagged_decoders.grc
\li fecapi_tagged_encoders.grc

*/
